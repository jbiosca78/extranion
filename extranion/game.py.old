import os
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = '1' # oculta mensaje de bienvenida de pygame
import pygame
from extranion.fps_stats import FPS_Stats
#from extranion.config import cfg_item, Config
from extranion.config import cfg
#from extranion.assets.assetmanager import AssetManager
#from extranion.assets.asset import AssetType
from extranion.asset import asset
from extranion.states.statemanager import StateManager
#from extranion.assets.soundmanager import SoundManager
import time

class Game:

	def __init__(self):
		print("Init Game")
		pygame.mixer.pre_init(44100, 16, 2, 4096)
		pygame.init()
		pygame.mouse.set_visible(False)

		self.__screen=pygame.display.set_mode(cfg("game.screen_size"), 0, 32)
		pygame.display.set_caption(cfg("game.name"))

		self.__debug=cfg("game.debug.activated")
		self.__time_per_frame=1000.0/cfg("timing.fps")
		self.__load_assets()
		self.__fps_stats=FPS_Stats()
		self.__state_manager=StateManager()
		self.__running=True

	def run(self):
		last_time = pygame.time.get_ticks()
		time_since_last_update = 0
		time_prev=last_time
		while self.__running:
			#delta_time, last_time = self.__calc_delta_time(last_time)
			current_time = pygame.time.get_ticks()
			delta_time = current_time-last_time
			last_time=current_time
			time_since_last_update += delta_time

			time_prev=pygame.time.get_ticks() # para contar lo que tarda en ejecutar el último update y render
			# actualizamos los frames necesarios para mantener el tiempo de actualización de juego (frames lógicos)
			while time_since_last_update > self.__time_per_frame:
				time_prev=pygame.time.get_ticks() # si tenemos que generar varios frames, sólo contamos el último
				time_since_last_update -= self.__time_per_frame
				self.__handle_input()
				self.__update_game(self.__time_per_frame)
			self.__render()
			time_post=pygame.time.get_ticks() # para contar lo que tarda en ejecutar el último update y render

			# Si no estamos en debug, esperamos el tiempo sobrante entre frames
			# restando el tiempo que tardamos en generar un frame (time_post-time_prev)
			# para evitar sobrecargar la CPU
			if not self.__debug:
				if (time_post-time_prev)<self.__time_per_frame:
					time.sleep((self.__time_per_frame-(time_post-time_prev))/1000)

		self.__release()

	def __handle_input(self):
		for event in pygame.event.get():
			if event.type == pygame.QUIT: self.__running=False
			elif event.type == pygame.KEYDOWN:
				if event.key == pygame.K_ESCAPE: self.__running=False
				elif event.key == pygame.K_F5: self.__debug=not self.__debug
		#	self.__state_manager.handle_input(event)
		pass

	def __update_game(self, delta_time):
		self.__state_manager.update(delta_time)
		self.__fps_stats.update(delta_time)
		#SoundManager.instance().update(delta_time)

	def __render(self):
		self.__screen.fill(cfg("game.background_color"))
		self.__state_manager.render(self.__screen)
		if self.__debug: self.__fps_stats.render(self.__screen)
		pygame.display.update()

	def __release(self):
		self.__state_manager.quit()
		self.__unload_assets()
		pygame.quit()

	def __load_assets(self):
		print("load_assets")
		asset.load('main','fonts.sansation')
		#cfg("font.name"), cfg("font.font_file"), font_size = cfg("font.size"))

	def __unload_assets(self):
		#AssetManager.instance().clear('main')
		pass
